{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.7.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Errors_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Int
import Data.Typeable ( Typeable )
import qualified Data.Map as Map
import qualified Data.Set as Set

import Thrift


data EDAMErrorCode = UNKNOWN|BAD_DATA_FORMAT|PERMISSION_DENIED|INTERNAL_ERROR|DATA_REQUIRED|LIMIT_REACHED|QUOTA_REACHED|INVALID_AUTH|AUTH_EXPIRED|DATA_CONFLICT|ENML_VALIDATION|SHARD_UNAVAILABLE  deriving (Show,Eq, Typeable, Ord)
instance Enum EDAMErrorCode where
  fromEnum t = case t of
    UNKNOWN -> 1
    BAD_DATA_FORMAT -> 2
    PERMISSION_DENIED -> 3
    INTERNAL_ERROR -> 4
    DATA_REQUIRED -> 5
    LIMIT_REACHED -> 6
    QUOTA_REACHED -> 7
    INVALID_AUTH -> 8
    AUTH_EXPIRED -> 9
    DATA_CONFLICT -> 10
    ENML_VALIDATION -> 11
    SHARD_UNAVAILABLE -> 12
  toEnum t = case t of
    1 -> UNKNOWN
    2 -> BAD_DATA_FORMAT
    3 -> PERMISSION_DENIED
    4 -> INTERNAL_ERROR
    5 -> DATA_REQUIRED
    6 -> LIMIT_REACHED
    7 -> QUOTA_REACHED
    8 -> INVALID_AUTH
    9 -> AUTH_EXPIRED
    10 -> DATA_CONFLICT
    11 -> ENML_VALIDATION
    12 -> SHARD_UNAVAILABLE
    _ -> throw ThriftException
data EDAMUserException = EDAMUserException{f_EDAMUserException_errorCode :: Maybe EDAMErrorCode,f_EDAMUserException_parameter :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception EDAMUserException
write_EDAMUserException oprot record = do
  writeStructBegin oprot "EDAMUserException"
  case f_EDAMUserException_errorCode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("errorCode",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_EDAMUserException_parameter record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parameter",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EDAMUserException_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_EDAMUserException_fields iprot record{f_EDAMUserException_errorCode=Just s}
        else do
          skip iprot _t3
          read_EDAMUserException_fields iprot record
      2 -> if _t3 == T_STRING then do
        s <- readString iprot
        read_EDAMUserException_fields iprot record{f_EDAMUserException_parameter=Just s}
        else do
          skip iprot _t3
          read_EDAMUserException_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_EDAMUserException_fields iprot record
read_EDAMUserException iprot = do
  _ <- readStructBegin iprot
  record <- read_EDAMUserException_fields iprot (EDAMUserException{f_EDAMUserException_errorCode=Nothing,f_EDAMUserException_parameter=Nothing})
  readStructEnd iprot
  return record
data EDAMSystemException = EDAMSystemException{f_EDAMSystemException_errorCode :: Maybe EDAMErrorCode,f_EDAMSystemException_message :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception EDAMSystemException
write_EDAMSystemException oprot record = do
  writeStructBegin oprot "EDAMSystemException"
  case f_EDAMSystemException_errorCode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("errorCode",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_EDAMSystemException_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EDAMSystemException_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      1 -> if _t8 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_EDAMSystemException_fields iprot record{f_EDAMSystemException_errorCode=Just s}
        else do
          skip iprot _t8
          read_EDAMSystemException_fields iprot record
      2 -> if _t8 == T_STRING then do
        s <- readString iprot
        read_EDAMSystemException_fields iprot record{f_EDAMSystemException_message=Just s}
        else do
          skip iprot _t8
          read_EDAMSystemException_fields iprot record
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_EDAMSystemException_fields iprot record
read_EDAMSystemException iprot = do
  _ <- readStructBegin iprot
  record <- read_EDAMSystemException_fields iprot (EDAMSystemException{f_EDAMSystemException_errorCode=Nothing,f_EDAMSystemException_message=Nothing})
  readStructEnd iprot
  return record
data EDAMNotFoundException = EDAMNotFoundException{f_EDAMNotFoundException_identifier :: Maybe String,f_EDAMNotFoundException_key :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception EDAMNotFoundException
write_EDAMNotFoundException oprot record = do
  writeStructBegin oprot "EDAMNotFoundException"
  case f_EDAMNotFoundException_identifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("identifier",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_EDAMNotFoundException_key record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EDAMNotFoundException_fields iprot record = do
  (_,_t13,_id14) <- readFieldBegin iprot
  if _t13 == T_STOP then return record else
    case _id14 of 
      1 -> if _t13 == T_STRING then do
        s <- readString iprot
        read_EDAMNotFoundException_fields iprot record{f_EDAMNotFoundException_identifier=Just s}
        else do
          skip iprot _t13
          read_EDAMNotFoundException_fields iprot record
      2 -> if _t13 == T_STRING then do
        s <- readString iprot
        read_EDAMNotFoundException_fields iprot record{f_EDAMNotFoundException_key=Just s}
        else do
          skip iprot _t13
          read_EDAMNotFoundException_fields iprot record
      _ -> do
        skip iprot _t13
        readFieldEnd iprot
        read_EDAMNotFoundException_fields iprot record
read_EDAMNotFoundException iprot = do
  _ <- readStructBegin iprot
  record <- read_EDAMNotFoundException_fields iprot (EDAMNotFoundException{f_EDAMNotFoundException_identifier=Nothing,f_EDAMNotFoundException_key=Nothing})
  readStructEnd iprot
  return record
