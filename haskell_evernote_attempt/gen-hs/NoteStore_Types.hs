{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.7.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module NoteStore_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Int
import Data.Typeable ( Typeable )
import qualified Data.Map as Map
import qualified Data.Set as Set

import Thrift

import qualified UserStore_Types
import qualified Types_Types
import qualified Errors_Types
import qualified Limits_Types

import Types_Types
-- import Types_Types (read_Note, read_Notebook, read_Tag, read_SavedSearch)

data SyncState = SyncState{f_SyncState_currentTime :: Maybe Int64,f_SyncState_fullSyncBefore :: Maybe Int64,f_SyncState_updateCount :: Maybe Int32,f_SyncState_uploaded :: Maybe Int64} deriving (Show,Eq,Ord,Typeable)
write_SyncState oprot record = do
  writeStructBegin oprot "SyncState"
  case f_SyncState_currentTime record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("currentTime",T_I64,1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_SyncState_fullSyncBefore record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("fullSyncBefore",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_SyncState_updateCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateCount",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SyncState_uploaded record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("uploaded",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SyncState_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_SyncState_fields iprot record{f_SyncState_currentTime=Just s}
        else do
          skip iprot _t3
          read_SyncState_fields iprot record
      2 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_SyncState_fields iprot record{f_SyncState_fullSyncBefore=Just s}
        else do
          skip iprot _t3
          read_SyncState_fields iprot record
      3 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_SyncState_fields iprot record{f_SyncState_updateCount=Just s}
        else do
          skip iprot _t3
          read_SyncState_fields iprot record
      4 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_SyncState_fields iprot record{f_SyncState_uploaded=Just s}
        else do
          skip iprot _t3
          read_SyncState_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_SyncState_fields iprot record
read_SyncState iprot = do
  _ <- readStructBegin iprot
  record <- read_SyncState_fields iprot (SyncState{f_SyncState_currentTime=Nothing,f_SyncState_fullSyncBefore=Nothing,f_SyncState_updateCount=Nothing,f_SyncState_uploaded=Nothing})
  readStructEnd iprot
  return record
data SyncChunk = SyncChunk{f_SyncChunk_currentTime :: Maybe Int64,f_SyncChunk_chunkHighUSN :: Maybe Int32,f_SyncChunk_updateCount :: Maybe Int32,f_SyncChunk_notes :: Maybe [Types_Types.Note],f_SyncChunk_notebooks :: Maybe [Types_Types.Notebook],f_SyncChunk_tags :: Maybe [Types_Types.Tag],f_SyncChunk_searches :: Maybe [Types_Types.SavedSearch],f_SyncChunk_resources :: Maybe [Types_Types.Resource],f_SyncChunk_expungedNotes :: Maybe [String],f_SyncChunk_expungedNotebooks :: Maybe [String],f_SyncChunk_expungedTags :: Maybe [String],f_SyncChunk_expungedSearches :: Maybe [String],f_SyncChunk_linkedNotebooks :: Maybe [Types_Types.LinkedNotebook],f_SyncChunk_expungedLinkedNotebooks :: Maybe [String]} deriving (Show,Eq,Ord,Typeable)
write_SyncChunk oprot record = do
  writeStructBegin oprot "SyncChunk"
  case f_SyncChunk_currentTime record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("currentTime",T_I64,1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_SyncChunk_chunkHighUSN record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("chunkHighUSN",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SyncChunk_updateCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateCount",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SyncChunk_notes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notes",T_LIST,4)
    (let {f [] = return (); f (_viter7:t) = do {Types_Types.write_Note oprot _viter7;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_notebooks record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notebooks",T_LIST,5)
    (let {f [] = return (); f (_viter8:t) = do {Types_Types.write_Notebook oprot _viter8;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_tags record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tags",T_LIST,6)
    (let {f [] = return (); f (_viter9:t) = do {Types_Types.write_Tag oprot _viter9;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_searches record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("searches",T_LIST,7)
    (let {f [] = return (); f (_viter10:t) = do {Types_Types.write_SavedSearch oprot _viter10;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_resources record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("resources",T_LIST,8)
    (let {f [] = return (); f (_viter11:t) = do {Types_Types.write_Resource oprot _viter11;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_expungedNotes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expungedNotes",T_LIST,9)
    (let {f [] = return (); f (_viter12:t) = do {writeString oprot _viter12;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_expungedNotebooks record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expungedNotebooks",T_LIST,10)
    (let {f [] = return (); f (_viter13:t) = do {writeString oprot _viter13;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_expungedTags record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expungedTags",T_LIST,11)
    (let {f [] = return (); f (_viter14:t) = do {writeString oprot _viter14;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_expungedSearches record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expungedSearches",T_LIST,12)
    (let {f [] = return (); f (_viter15:t) = do {writeString oprot _viter15;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_linkedNotebooks record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("linkedNotebooks",T_LIST,13)
    (let {f [] = return (); f (_viter16:t) = do {Types_Types.write_LinkedNotebook oprot _viter16;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SyncChunk_expungedLinkedNotebooks record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("expungedLinkedNotebooks",T_LIST,14)
    (let {f [] = return (); f (_viter17:t) = do {writeString oprot _viter17;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SyncChunk_fields iprot record = do
  (_,_t19,_id20) <- readFieldBegin iprot
  if _t19 == T_STOP then return record else
    case _id20 of 
      1 -> if _t19 == T_I64 then do
        s <- readI64 iprot
        read_SyncChunk_fields iprot record{f_SyncChunk_currentTime=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      2 -> if _t19 == T_I32 then do
        s <- readI32 iprot
        read_SyncChunk_fields iprot record{f_SyncChunk_chunkHighUSN=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      3 -> if _t19 == T_I32 then do
        s <- readI32 iprot
        read_SyncChunk_fields iprot record{f_SyncChunk_updateCount=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      4 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Note iprot);r <- f (n-1); return $ v:r}} in do {(_etype24,_size21) <- readListBegin iprot; f _size21})
        read_SyncChunk_fields iprot record{f_SyncChunk_notes=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      5 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Notebook iprot);r <- f (n-1); return $ v:r}} in do {(_etype29,_size26) <- readListBegin iprot; f _size26})
        read_SyncChunk_fields iprot record{f_SyncChunk_notebooks=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      6 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Tag iprot);r <- f (n-1); return $ v:r}} in do {(_etype34,_size31) <- readListBegin iprot; f _size31})
        read_SyncChunk_fields iprot record{f_SyncChunk_tags=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      7 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_SavedSearch iprot);r <- f (n-1); return $ v:r}} in do {(_etype39,_size36) <- readListBegin iprot; f _size36})
        read_SyncChunk_fields iprot record{f_SyncChunk_searches=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      8 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Resource iprot);r <- f (n-1); return $ v:r}} in do {(_etype44,_size41) <- readListBegin iprot; f _size41})
        read_SyncChunk_fields iprot record{f_SyncChunk_resources=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      9 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype49,_size46) <- readListBegin iprot; f _size46})
        read_SyncChunk_fields iprot record{f_SyncChunk_expungedNotes=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      10 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype54,_size51) <- readListBegin iprot; f _size51})
        read_SyncChunk_fields iprot record{f_SyncChunk_expungedNotebooks=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      11 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype59,_size56) <- readListBegin iprot; f _size56})
        read_SyncChunk_fields iprot record{f_SyncChunk_expungedTags=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      12 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype64,_size61) <- readListBegin iprot; f _size61})
        read_SyncChunk_fields iprot record{f_SyncChunk_expungedSearches=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      13 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_LinkedNotebook iprot);r <- f (n-1); return $ v:r}} in do {(_etype69,_size66) <- readListBegin iprot; f _size66})
        read_SyncChunk_fields iprot record{f_SyncChunk_linkedNotebooks=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      14 -> if _t19 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype74,_size71) <- readListBegin iprot; f _size71})
        read_SyncChunk_fields iprot record{f_SyncChunk_expungedLinkedNotebooks=Just s}
        else do
          skip iprot _t19
          read_SyncChunk_fields iprot record
      _ -> do
        skip iprot _t19
        readFieldEnd iprot
        read_SyncChunk_fields iprot record
read_SyncChunk iprot = do
  _ <- readStructBegin iprot
  record <- read_SyncChunk_fields iprot (SyncChunk{f_SyncChunk_currentTime=Nothing,f_SyncChunk_chunkHighUSN=Nothing,f_SyncChunk_updateCount=Nothing,f_SyncChunk_notes=Nothing,f_SyncChunk_notebooks=Nothing,f_SyncChunk_tags=Nothing,f_SyncChunk_searches=Nothing,f_SyncChunk_resources=Nothing,f_SyncChunk_expungedNotes=Nothing,f_SyncChunk_expungedNotebooks=Nothing,f_SyncChunk_expungedTags=Nothing,f_SyncChunk_expungedSearches=Nothing,f_SyncChunk_linkedNotebooks=Nothing,f_SyncChunk_expungedLinkedNotebooks=Nothing})
  readStructEnd iprot
  return record
data NoteFilter = NoteFilter{f_NoteFilter_order :: Maybe Int32,f_NoteFilter_ascending :: Maybe Bool,f_NoteFilter_words :: Maybe String,f_NoteFilter_notebookGuid :: Maybe String,f_NoteFilter_tagGuids :: Maybe [String],f_NoteFilter_timeZone :: Maybe String,f_NoteFilter_inactive :: Maybe Bool} deriving (Show,Eq,Ord,Typeable)
write_NoteFilter oprot record = do
  writeStructBegin oprot "NoteFilter"
  case f_NoteFilter_order record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("order",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteFilter_ascending record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ascending",T_BOOL,2)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NoteFilter_words record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("words",T_STRING,3)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteFilter_notebookGuid record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notebookGuid",T_STRING,4)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteFilter_tagGuids record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tagGuids",T_LIST,5)
    (let {f [] = return (); f (_viter78:t) = do {writeString oprot _viter78;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteFilter_timeZone record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timeZone",T_STRING,6)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteFilter_inactive record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inactive",T_BOOL,7)
    writeBool oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteFilter_fields iprot record = do
  (_,_t80,_id81) <- readFieldBegin iprot
  if _t80 == T_STOP then return record else
    case _id81 of 
      1 -> if _t80 == T_I32 then do
        s <- readI32 iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_order=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      2 -> if _t80 == T_BOOL then do
        s <- readBool iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_ascending=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      3 -> if _t80 == T_STRING then do
        s <- readString iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_words=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      4 -> if _t80 == T_STRING then do
        s <- readString iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_notebookGuid=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      5 -> if _t80 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype85,_size82) <- readListBegin iprot; f _size82})
        read_NoteFilter_fields iprot record{f_NoteFilter_tagGuids=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      6 -> if _t80 == T_STRING then do
        s <- readString iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_timeZone=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      7 -> if _t80 == T_BOOL then do
        s <- readBool iprot
        read_NoteFilter_fields iprot record{f_NoteFilter_inactive=Just s}
        else do
          skip iprot _t80
          read_NoteFilter_fields iprot record
      _ -> do
        skip iprot _t80
        readFieldEnd iprot
        read_NoteFilter_fields iprot record
read_NoteFilter iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteFilter_fields iprot (NoteFilter{f_NoteFilter_order=Nothing,f_NoteFilter_ascending=Nothing,f_NoteFilter_words=Nothing,f_NoteFilter_notebookGuid=Nothing,f_NoteFilter_tagGuids=Nothing,f_NoteFilter_timeZone=Nothing,f_NoteFilter_inactive=Nothing})
  readStructEnd iprot
  return record
data NoteList = NoteList{f_NoteList_startIndex :: Maybe Int32,f_NoteList_totalNotes :: Maybe Int32,f_NoteList_notes :: Maybe [Types_Types.Note],f_NoteList_stoppedWords :: Maybe [String],f_NoteList_searchedWords :: Maybe [String],f_NoteList_updateCount :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_NoteList oprot record = do
  writeStructBegin oprot "NoteList"
  case f_NoteList_startIndex record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startIndex",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteList_totalNotes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("totalNotes",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteList_notes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notes",T_LIST,3)
    (let {f [] = return (); f (_viter89:t) = do {Types_Types.write_Note oprot _viter89;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteList_stoppedWords record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stoppedWords",T_LIST,4)
    (let {f [] = return (); f (_viter90:t) = do {writeString oprot _viter90;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteList_searchedWords record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("searchedWords",T_LIST,5)
    (let {f [] = return (); f (_viter91:t) = do {writeString oprot _viter91;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteList_updateCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateCount",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteList_fields iprot record = do
  (_,_t93,_id94) <- readFieldBegin iprot
  if _t93 == T_STOP then return record else
    case _id94 of 
      1 -> if _t93 == T_I32 then do
        s <- readI32 iprot
        read_NoteList_fields iprot record{f_NoteList_startIndex=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      2 -> if _t93 == T_I32 then do
        s <- readI32 iprot
        read_NoteList_fields iprot record{f_NoteList_totalNotes=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      3 -> if _t93 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Note iprot);r <- f (n-1); return $ v:r}} in do {(_etype98,_size95) <- readListBegin iprot; f _size95})
        read_NoteList_fields iprot record{f_NoteList_notes=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      4 -> if _t93 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype103,_size100) <- readListBegin iprot; f _size100})
        read_NoteList_fields iprot record{f_NoteList_stoppedWords=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      5 -> if _t93 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype108,_size105) <- readListBegin iprot; f _size105})
        read_NoteList_fields iprot record{f_NoteList_searchedWords=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      6 -> if _t93 == T_I32 then do
        s <- readI32 iprot
        read_NoteList_fields iprot record{f_NoteList_updateCount=Just s}
        else do
          skip iprot _t93
          read_NoteList_fields iprot record
      _ -> do
        skip iprot _t93
        readFieldEnd iprot
        read_NoteList_fields iprot record
read_NoteList iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteList_fields iprot (NoteList{f_NoteList_startIndex=Nothing,f_NoteList_totalNotes=Nothing,f_NoteList_notes=Nothing,f_NoteList_stoppedWords=Nothing,f_NoteList_searchedWords=Nothing,f_NoteList_updateCount=Nothing})
  readStructEnd iprot
  return record
data NoteMetadata = NoteMetadata{f_NoteMetadata_guid :: Maybe String,f_NoteMetadata_title :: Maybe String,f_NoteMetadata_contentLength :: Maybe Int32,f_NoteMetadata_created :: Maybe Int64,f_NoteMetadata_updated :: Maybe Int64,f_NoteMetadata_updateSequenceNum :: Maybe Int32,f_NoteMetadata_notebookGuid :: Maybe String,f_NoteMetadata_tagGuids :: Maybe [String],f_NoteMetadata_attributes :: Maybe Types_Types.NoteAttributes,f_NoteMetadata_largestResourceMime :: Maybe String,f_NoteMetadata_largestResourceSize :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_NoteMetadata oprot record = do
  writeStructBegin oprot "NoteMetadata"
  case f_NoteMetadata_guid record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("guid",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_title record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("title",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_contentLength record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("contentLength",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_created record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("created",T_I64,6)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_updated record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updated",T_I64,7)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_updateSequenceNum record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateSequenceNum",T_I32,10)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_notebookGuid record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notebookGuid",T_STRING,11)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_tagGuids record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tagGuids",T_LIST,12)
    (let {f [] = return (); f (_viter112:t) = do {writeString oprot _viter112;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteMetadata_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_STRUCT,14)
    Types_Types.write_NoteAttributes oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_largestResourceMime record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("largestResourceMime",T_STRING,20)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteMetadata_largestResourceSize record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("largestResourceSize",T_I32,21)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteMetadata_fields iprot record = do
  (_,_t114,_id115) <- readFieldBegin iprot
  if _t114 == T_STOP then return record else
    case _id115 of 
      1 -> if _t114 == T_STRING then do
        s <- readString iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_guid=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      2 -> if _t114 == T_STRING then do
        s <- readString iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_title=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      5 -> if _t114 == T_I32 then do
        s <- readI32 iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_contentLength=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      6 -> if _t114 == T_I64 then do
        s <- readI64 iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_created=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      7 -> if _t114 == T_I64 then do
        s <- readI64 iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_updated=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      10 -> if _t114 == T_I32 then do
        s <- readI32 iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_updateSequenceNum=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      11 -> if _t114 == T_STRING then do
        s <- readString iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_notebookGuid=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      12 -> if _t114 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype119,_size116) <- readListBegin iprot; f _size116})
        read_NoteMetadata_fields iprot record{f_NoteMetadata_tagGuids=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      14 -> if _t114 == T_STRUCT then do
        s <- (read_NoteAttributes iprot)
        read_NoteMetadata_fields iprot record{f_NoteMetadata_attributes=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      20 -> if _t114 == T_STRING then do
        s <- readString iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_largestResourceMime=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      21 -> if _t114 == T_I32 then do
        s <- readI32 iprot
        read_NoteMetadata_fields iprot record{f_NoteMetadata_largestResourceSize=Just s}
        else do
          skip iprot _t114
          read_NoteMetadata_fields iprot record
      _ -> do
        skip iprot _t114
        readFieldEnd iprot
        read_NoteMetadata_fields iprot record
read_NoteMetadata iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteMetadata_fields iprot (NoteMetadata{f_NoteMetadata_guid=Nothing,f_NoteMetadata_title=Nothing,f_NoteMetadata_contentLength=Nothing,f_NoteMetadata_created=Nothing,f_NoteMetadata_updated=Nothing,f_NoteMetadata_updateSequenceNum=Nothing,f_NoteMetadata_notebookGuid=Nothing,f_NoteMetadata_tagGuids=Nothing,f_NoteMetadata_attributes=Nothing,f_NoteMetadata_largestResourceMime=Nothing,f_NoteMetadata_largestResourceSize=Nothing})
  readStructEnd iprot
  return record
data NotesMetadataList = NotesMetadataList{f_NotesMetadataList_startIndex :: Maybe Int32,f_NotesMetadataList_totalNotes :: Maybe Int32,f_NotesMetadataList_notes :: Maybe [NoteMetadata],f_NotesMetadataList_stoppedWords :: Maybe [String],f_NotesMetadataList_searchedWords :: Maybe [String],f_NotesMetadataList_updateCount :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_NotesMetadataList oprot record = do
  writeStructBegin oprot "NotesMetadataList"
  case f_NotesMetadataList_startIndex record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startIndex",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataList_totalNotes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("totalNotes",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataList_notes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notes",T_LIST,3)
    (let {f [] = return (); f (_viter123:t) = do {write_NoteMetadata oprot _viter123;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NotesMetadataList_stoppedWords record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stoppedWords",T_LIST,4)
    (let {f [] = return (); f (_viter124:t) = do {writeString oprot _viter124;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NotesMetadataList_searchedWords record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("searchedWords",T_LIST,5)
    (let {f [] = return (); f (_viter125:t) = do {writeString oprot _viter125;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NotesMetadataList_updateCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateCount",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NotesMetadataList_fields iprot record = do
  (_,_t127,_id128) <- readFieldBegin iprot
  if _t127 == T_STOP then return record else
    case _id128 of 
      1 -> if _t127 == T_I32 then do
        s <- readI32 iprot
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_startIndex=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      2 -> if _t127 == T_I32 then do
        s <- readI32 iprot
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_totalNotes=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      3 -> if _t127 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_NoteMetadata iprot);r <- f (n-1); return $ v:r}} in do {(_etype132,_size129) <- readListBegin iprot; f _size129})
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_notes=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      4 -> if _t127 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype137,_size134) <- readListBegin iprot; f _size134})
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_stoppedWords=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      5 -> if _t127 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype142,_size139) <- readListBegin iprot; f _size139})
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_searchedWords=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      6 -> if _t127 == T_I32 then do
        s <- readI32 iprot
        read_NotesMetadataList_fields iprot record{f_NotesMetadataList_updateCount=Just s}
        else do
          skip iprot _t127
          read_NotesMetadataList_fields iprot record
      _ -> do
        skip iprot _t127
        readFieldEnd iprot
        read_NotesMetadataList_fields iprot record
read_NotesMetadataList iprot = do
  _ <- readStructBegin iprot
  record <- read_NotesMetadataList_fields iprot (NotesMetadataList{f_NotesMetadataList_startIndex=Nothing,f_NotesMetadataList_totalNotes=Nothing,f_NotesMetadataList_notes=Nothing,f_NotesMetadataList_stoppedWords=Nothing,f_NotesMetadataList_searchedWords=Nothing,f_NotesMetadataList_updateCount=Nothing})
  readStructEnd iprot
  return record
data NotesMetadataResultSpec = NotesMetadataResultSpec{f_NotesMetadataResultSpec_includeTitle :: Maybe Bool,f_NotesMetadataResultSpec_includeContentLength :: Maybe Bool,f_NotesMetadataResultSpec_includeCreated :: Maybe Bool,f_NotesMetadataResultSpec_includeUpdated :: Maybe Bool,f_NotesMetadataResultSpec_includeUpdateSequenceNum :: Maybe Bool,f_NotesMetadataResultSpec_includeNotebookGuid :: Maybe Bool,f_NotesMetadataResultSpec_includeTagGuids :: Maybe Bool,f_NotesMetadataResultSpec_includeAttributes :: Maybe Bool,f_NotesMetadataResultSpec_includeLargestResourceMime :: Maybe Bool,f_NotesMetadataResultSpec_includeLargestResourceSize :: Maybe Bool} deriving (Show,Eq,Ord,Typeable)
write_NotesMetadataResultSpec oprot record = do
  writeStructBegin oprot "NotesMetadataResultSpec"
  case f_NotesMetadataResultSpec_includeTitle record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeTitle",T_BOOL,2)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeContentLength record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeContentLength",T_BOOL,5)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeCreated record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeCreated",T_BOOL,6)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeUpdated record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeUpdated",T_BOOL,7)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeUpdateSequenceNum record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeUpdateSequenceNum",T_BOOL,10)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeNotebookGuid record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeNotebookGuid",T_BOOL,11)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeTagGuids record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeTagGuids",T_BOOL,12)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeAttributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeAttributes",T_BOOL,14)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeLargestResourceMime record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeLargestResourceMime",T_BOOL,20)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_NotesMetadataResultSpec_includeLargestResourceSize record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("includeLargestResourceSize",T_BOOL,21)
    writeBool oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NotesMetadataResultSpec_fields iprot record = do
  (_,_t147,_id148) <- readFieldBegin iprot
  if _t147 == T_STOP then return record else
    case _id148 of 
      2 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeTitle=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      5 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeContentLength=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      6 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeCreated=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      7 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeUpdated=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      10 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeUpdateSequenceNum=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      11 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeNotebookGuid=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      12 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeTagGuids=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      14 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeAttributes=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      20 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeLargestResourceMime=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      21 -> if _t147 == T_BOOL then do
        s <- readBool iprot
        read_NotesMetadataResultSpec_fields iprot record{f_NotesMetadataResultSpec_includeLargestResourceSize=Just s}
        else do
          skip iprot _t147
          read_NotesMetadataResultSpec_fields iprot record
      _ -> do
        skip iprot _t147
        readFieldEnd iprot
        read_NotesMetadataResultSpec_fields iprot record
read_NotesMetadataResultSpec iprot = do
  _ <- readStructBegin iprot
  record <- read_NotesMetadataResultSpec_fields iprot (NotesMetadataResultSpec{f_NotesMetadataResultSpec_includeTitle=Nothing,f_NotesMetadataResultSpec_includeContentLength=Nothing,f_NotesMetadataResultSpec_includeCreated=Nothing,f_NotesMetadataResultSpec_includeUpdated=Nothing,f_NotesMetadataResultSpec_includeUpdateSequenceNum=Nothing,f_NotesMetadataResultSpec_includeNotebookGuid=Nothing,f_NotesMetadataResultSpec_includeTagGuids=Nothing,f_NotesMetadataResultSpec_includeAttributes=Nothing,f_NotesMetadataResultSpec_includeLargestResourceMime=Nothing,f_NotesMetadataResultSpec_includeLargestResourceSize=Nothing})
  readStructEnd iprot
  return record
data NoteCollectionCounts = NoteCollectionCounts{f_NoteCollectionCounts_notebookCounts :: Maybe (Map.Map String Int32),f_NoteCollectionCounts_tagCounts :: Maybe (Map.Map String Int32),f_NoteCollectionCounts_trashCount :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_NoteCollectionCounts oprot record = do
  writeStructBegin oprot "NoteCollectionCounts"
  case f_NoteCollectionCounts_notebookCounts record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("notebookCounts",T_MAP,1)
    (let {f [] = return (); f ((_kiter151,_viter152):t) = do {do {writeString oprot _kiter151;writeI32 oprot _viter152};f t}} in do {writeMapBegin oprot (T_STRING,T_I32,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_NoteCollectionCounts_tagCounts record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tagCounts",T_MAP,2)
    (let {f [] = return (); f ((_kiter153,_viter154):t) = do {do {writeString oprot _kiter153;writeI32 oprot _viter154};f t}} in do {writeMapBegin oprot (T_STRING,T_I32,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_NoteCollectionCounts_trashCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("trashCount",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteCollectionCounts_fields iprot record = do
  (_,_t156,_id157) <- readFieldBegin iprot
  if _t156 == T_STOP then return record else
    case _id157 of 
      1 -> if _t156 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- readI32 iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype159,_vtype160,_size158) <- readMapBegin iprot; l <- f _size158; return $ Map.fromList l})
        read_NoteCollectionCounts_fields iprot record{f_NoteCollectionCounts_notebookCounts=Just s}
        else do
          skip iprot _t156
          read_NoteCollectionCounts_fields iprot record
      2 -> if _t156 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- readI32 iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype164,_vtype165,_size163) <- readMapBegin iprot; l <- f _size163; return $ Map.fromList l})
        read_NoteCollectionCounts_fields iprot record{f_NoteCollectionCounts_tagCounts=Just s}
        else do
          skip iprot _t156
          read_NoteCollectionCounts_fields iprot record
      3 -> if _t156 == T_I32 then do
        s <- readI32 iprot
        read_NoteCollectionCounts_fields iprot record{f_NoteCollectionCounts_trashCount=Just s}
        else do
          skip iprot _t156
          read_NoteCollectionCounts_fields iprot record
      _ -> do
        skip iprot _t156
        readFieldEnd iprot
        read_NoteCollectionCounts_fields iprot record
read_NoteCollectionCounts iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteCollectionCounts_fields iprot (NoteCollectionCounts{f_NoteCollectionCounts_notebookCounts=Nothing,f_NoteCollectionCounts_tagCounts=Nothing,f_NoteCollectionCounts_trashCount=Nothing})
  readStructEnd iprot
  return record
data AdImpressions = AdImpressions{f_AdImpressions_adId :: Maybe Int32,f_AdImpressions_impressionCount :: Maybe Int32,f_AdImpressions_impressionTime :: Maybe Int32} deriving (Show,Eq,Ord,Typeable)
write_AdImpressions oprot record = do
  writeStructBegin oprot "AdImpressions"
  case f_AdImpressions_adId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("adId",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AdImpressions_impressionCount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("impressionCount",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AdImpressions_impressionTime record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("impressionTime",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AdImpressions_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      1 -> if _t171 == T_I32 then do
        s <- readI32 iprot
        read_AdImpressions_fields iprot record{f_AdImpressions_adId=Just s}
        else do
          skip iprot _t171
          read_AdImpressions_fields iprot record
      2 -> if _t171 == T_I32 then do
        s <- readI32 iprot
        read_AdImpressions_fields iprot record{f_AdImpressions_impressionCount=Just s}
        else do
          skip iprot _t171
          read_AdImpressions_fields iprot record
      3 -> if _t171 == T_I32 then do
        s <- readI32 iprot
        read_AdImpressions_fields iprot record{f_AdImpressions_impressionTime=Just s}
        else do
          skip iprot _t171
          read_AdImpressions_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_AdImpressions_fields iprot record
read_AdImpressions iprot = do
  _ <- readStructBegin iprot
  record <- read_AdImpressions_fields iprot (AdImpressions{f_AdImpressions_adId=Nothing,f_AdImpressions_impressionCount=Nothing,f_AdImpressions_impressionTime=Nothing})
  readStructEnd iprot
  return record
data AdParameters = AdParameters{f_AdParameters_clientLanguage :: Maybe String,f_AdParameters_impressions :: Maybe [AdImpressions],f_AdParameters_supportHtml :: Maybe Bool,f_AdParameters_clientProperties :: Maybe (Map.Map String String)} deriving (Show,Eq,Ord,Typeable)
write_AdParameters oprot record = do
  writeStructBegin oprot "AdParameters"
  case f_AdParameters_clientLanguage record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("clientLanguage",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_AdParameters_impressions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("impressions",T_LIST,4)
    (let {f [] = return (); f (_viter175:t) = do {write_AdImpressions oprot _viter175;f t}} in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_AdParameters_supportHtml record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("supportHtml",T_BOOL,5)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_AdParameters_clientProperties record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("clientProperties",T_MAP,6)
    (let {f [] = return (); f ((_kiter176,_viter177):t) = do {do {writeString oprot _kiter176;writeString oprot _viter177};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AdParameters_fields iprot record = do
  (_,_t179,_id180) <- readFieldBegin iprot
  if _t179 == T_STOP then return record else
    case _id180 of 
      2 -> if _t179 == T_STRING then do
        s <- readString iprot
        read_AdParameters_fields iprot record{f_AdParameters_clientLanguage=Just s}
        else do
          skip iprot _t179
          read_AdParameters_fields iprot record
      4 -> if _t179 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_AdImpressions iprot);r <- f (n-1); return $ v:r}} in do {(_etype184,_size181) <- readListBegin iprot; f _size181})
        read_AdParameters_fields iprot record{f_AdParameters_impressions=Just s}
        else do
          skip iprot _t179
          read_AdParameters_fields iprot record
      5 -> if _t179 == T_BOOL then do
        s <- readBool iprot
        read_AdParameters_fields iprot record{f_AdParameters_supportHtml=Just s}
        else do
          skip iprot _t179
          read_AdParameters_fields iprot record
      6 -> if _t179 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- readString iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype187,_vtype188,_size186) <- readMapBegin iprot; l <- f _size186; return $ Map.fromList l})
        read_AdParameters_fields iprot record{f_AdParameters_clientProperties=Just s}
        else do
          skip iprot _t179
          read_AdParameters_fields iprot record
      _ -> do
        skip iprot _t179
        readFieldEnd iprot
        read_AdParameters_fields iprot record
read_AdParameters iprot = do
  _ <- readStructBegin iprot
  record <- read_AdParameters_fields iprot (AdParameters{f_AdParameters_clientLanguage=Nothing,f_AdParameters_impressions=Nothing,f_AdParameters_supportHtml=Nothing,f_AdParameters_clientProperties=Nothing})
  readStructEnd iprot
  return record
data NoteEmailParameters = NoteEmailParameters{f_NoteEmailParameters_guid :: Maybe String,f_NoteEmailParameters_note :: Maybe Types_Types.Note,f_NoteEmailParameters_toAddresses :: Maybe [String],f_NoteEmailParameters_ccAddresses :: Maybe [String],f_NoteEmailParameters_subject :: Maybe String,f_NoteEmailParameters_message :: Maybe String} deriving (Show,Eq,Ord,Typeable)
write_NoteEmailParameters oprot record = do
  writeStructBegin oprot "NoteEmailParameters"
  case f_NoteEmailParameters_guid record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("guid",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteEmailParameters_note record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("note",T_STRUCT,2)
    Types_Types.write_Note oprot _v
    writeFieldEnd oprot}
  case f_NoteEmailParameters_toAddresses record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("toAddresses",T_LIST,3)
    (let {f [] = return (); f (_viter193:t) = do {writeString oprot _viter193;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteEmailParameters_ccAddresses record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ccAddresses",T_LIST,4)
    (let {f [] = return (); f (_viter194:t) = do {writeString oprot _viter194;f t}} in do {writeListBegin oprot (T_STRING,fromIntegral $ Prelude.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NoteEmailParameters_subject record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("subject",T_STRING,5)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NoteEmailParameters_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,6)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteEmailParameters_fields iprot record = do
  (_,_t196,_id197) <- readFieldBegin iprot
  if _t196 == T_STOP then return record else
    case _id197 of 
      1 -> if _t196 == T_STRING then do
        s <- readString iprot
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_guid=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      2 -> if _t196 == T_STRUCT then do
        s <- (read_Note iprot)
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_note=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      3 -> if _t196 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype201,_size198) <- readListBegin iprot; f _size198})
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_toAddresses=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      4 -> if _t196 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype206,_size203) <- readListBegin iprot; f _size203})
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_ccAddresses=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      5 -> if _t196 == T_STRING then do
        s <- readString iprot
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_subject=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      6 -> if _t196 == T_STRING then do
        s <- readString iprot
        read_NoteEmailParameters_fields iprot record{f_NoteEmailParameters_message=Just s}
        else do
          skip iprot _t196
          read_NoteEmailParameters_fields iprot record
      _ -> do
        skip iprot _t196
        readFieldEnd iprot
        read_NoteEmailParameters_fields iprot record
read_NoteEmailParameters iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteEmailParameters_fields iprot (NoteEmailParameters{f_NoteEmailParameters_guid=Nothing,f_NoteEmailParameters_note=Nothing,f_NoteEmailParameters_toAddresses=Nothing,f_NoteEmailParameters_ccAddresses=Nothing,f_NoteEmailParameters_subject=Nothing,f_NoteEmailParameters_message=Nothing})
  readStructEnd iprot
  return record
data NoteVersionId = NoteVersionId{f_NoteVersionId_updateSequenceNum :: Maybe Int32,f_NoteVersionId_updated :: Maybe Int64,f_NoteVersionId_saved :: Maybe Int64,f_NoteVersionId_title :: Maybe String} deriving (Show,Eq,Ord,Typeable)
write_NoteVersionId oprot record = do
  writeStructBegin oprot "NoteVersionId"
  case f_NoteVersionId_updateSequenceNum record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updateSequenceNum",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NoteVersionId_updated record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("updated",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_NoteVersionId_saved record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("saved",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_NoteVersionId_title record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("title",T_STRING,4)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NoteVersionId_fields iprot record = do
  (_,_t211,_id212) <- readFieldBegin iprot
  if _t211 == T_STOP then return record else
    case _id212 of 
      1 -> if _t211 == T_I32 then do
        s <- readI32 iprot
        read_NoteVersionId_fields iprot record{f_NoteVersionId_updateSequenceNum=Just s}
        else do
          skip iprot _t211
          read_NoteVersionId_fields iprot record
      2 -> if _t211 == T_I64 then do
        s <- readI64 iprot
        read_NoteVersionId_fields iprot record{f_NoteVersionId_updated=Just s}
        else do
          skip iprot _t211
          read_NoteVersionId_fields iprot record
      3 -> if _t211 == T_I64 then do
        s <- readI64 iprot
        read_NoteVersionId_fields iprot record{f_NoteVersionId_saved=Just s}
        else do
          skip iprot _t211
          read_NoteVersionId_fields iprot record
      4 -> if _t211 == T_STRING then do
        s <- readString iprot
        read_NoteVersionId_fields iprot record{f_NoteVersionId_title=Just s}
        else do
          skip iprot _t211
          read_NoteVersionId_fields iprot record
      _ -> do
        skip iprot _t211
        readFieldEnd iprot
        read_NoteVersionId_fields iprot record
read_NoteVersionId iprot = do
  _ <- readStructBegin iprot
  record <- read_NoteVersionId_fields iprot (NoteVersionId{f_NoteVersionId_updateSequenceNum=Nothing,f_NoteVersionId_updated=Nothing,f_NoteVersionId_saved=Nothing,f_NoteVersionId_title=Nothing})
  readStructEnd iprot
  return record
